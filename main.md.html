<h1 id="uni-it-security-notes">Uni IT Security Notes</h1>
<h2 id="basics">Basics</h2>
<h3 id="security-mindset">Security Mindset</h3>
<ul>
<li>Focus on weaknesses, not on features</li>
<li>Don’t rely on the “good case”</li>
<li>Anticipate what an attacker could do to a system</li>
<li>Weight security against user experience and privacy</li>
</ul>
<h3 id="security-objectives">Security Objectives</h3>
<ul>
<li><strong>Confidentiality</strong>/<code>conf</code>
<ul>
<li>Nobody but the legitimate receiver can read a message</li>
<li>Third party cannot gain access to communication patterns</li>
</ul></li>
<li><strong>Integrity</strong>/<code>int</code>: The contents of communication can’t be changed</li>
<li><strong>Authenticity</strong>/<code>authN</code>
<ul>
<li><strong>Entity Authentication</strong>: Communication partners can prove their respective identity to one another</li>
<li><strong>Message Authentication</strong>: It can be verified that a message is authentic (unaltered and sent by the correct entity)</li>
</ul></li>
<li><strong>Authorization</strong>/<code>authZ</code>
<ul>
<li>Service or information is only available to those who have correct access rights</li>
<li>Depends on authentication being set up</li>
</ul></li>
<li><strong>Non-Repudiation</strong>/<code>nRep</code>: A sender cannot deny having sent a message or used a service</li>
<li><strong>Availability</strong>/<code>avail</code>: Service is available with sufficient performance</li>
<li><strong>Access Control</strong>/<code>ac</code>: Access to services and information is controlled</li>
<li><strong>Privacy</strong>/<code>priv</code>
<ul>
<li>Restricted access to identity-related data</li>
<li>Anonymity</li>
<li>Pseudonymity</li>
</ul></li>
</ul>
<h3 id="attacks-threats-and-vulnerabilities">Attacks, Threats and Vulnerabilities</h3>
<ul>
<li><strong>Attacker</strong>: A person who has the skill and motivation to carry out an attack: The steps needed to carry out an attack</li>
<li><strong>Vulnerability</strong>: Some characteristics of the target that can result in a security breach</li>
<li><strong>Threat</strong>: Combination of an attacker, an attack vector and a vulnerability</li>
<li><strong>Attack</strong>: A threat that has been realized and has caused a security breach</li>
</ul>
<h3 id="threat-identification">Threat Identification</h3>
<ul>
<li>Define <strong>system boundaries</strong>: What is part of your system, what is not?</li>
<li>Define <strong>security objectives</strong>: What is important for your system to be secure?</li>
<li><strong>List all threats</strong> you can think of: Brainstorming and discussion with experts</li>
<li>Use <strong>conventions</strong>:
<ul>
<li>Similar threat models</li>
<li>Requirement specifications</li>
<li>How to break or circumvent the specifications</li>
<li>Note security assumptions of the system</li>
<li>Be careful with perimeter security: What if perimeter has been breached?</li>
<li>Note <em>possible</em>, but not yet exploitable vulnerabilities</li>
</ul></li>
</ul>
<h2 id="security-frameworks">Security Frameworks</h2>
<h3 id="network-specific-threat-examples">Network Specific Threat Examples</h3>
<ul>
<li>Remote Attacks</li>
<li>Eavesdropping: Sniffing of information</li>
<li>Altering information</li>
<li>Spoofing</li>
<li>DoS</li>
<li>Session hijacking</li>
<li>Viruses attacking clients</li>
<li>Spam</li>
<li>Phishing</li>
<li>Data trails/privacy leaks</li>
</ul>
<h3 id="stride-attacks-on-a-multi-user-system">STRIDE: Attacks on a Multi-User System</h3>
<ul>
<li><strong>S</strong>poofing of Identity</li>
<li><strong>T</strong>ampering with Information</li>
<li><strong>R</strong>epudiation</li>
<li><strong>I</strong>nformation Disclosure</li>
<li><strong>D</strong>oS</li>
<li><strong>E</strong>scalation of Privileges</li>
</ul>
<h3 id="security-policies">Security policies</h3>
<ul>
<li>Classification of system states into “allowed” and “forbidden” states</li>
<li>Secure system: Is only in allowed states</li>
<li>Breached system: Is in forbidden state</li>
</ul>
<h2 id="malware">Malware</h2>
<ul>
<li>Performs unwanted functions</li>
<li>Often runs without user’s consent</li>
<li>Telemetry (often hidden in proprietary software behind EULAs)</li>
<li>Backdoors</li>
</ul>
<h2 id="networking">Networking</h2>
<h3 id="tcp-overview">TCP Overview</h3>
<ul>
<li>Characteristics
<ul>
<li>Reliable</li>
<li>Connection-Oriented</li>
<li>Full-Duplex</li>
<li>Layer atop IP</li>
<li>Connection management: Setup, Release and Abort</li>
<li>Ordered delivery (package sequence control)</li>
<li>Repetition of lost packets</li>
<li>End-to-End ACKs</li>
<li>Checksum in header</li>
</ul></li>
<li>Identified by a 5-tuple
<ul>
<li>Source IP</li>
<li>Destination IP</li>
<li>Transport Protocol</li>
<li>Source Port</li>
<li>Destination Port</li>
</ul></li>
</ul>
<h3 id="tcp-connection-establishment">TCP Connection Establishment</h3>
<ul>
<li>Virtual connection between two systems</li>
<li>3-Way-Handshake with connection states</li>
</ul>
<p>An example connection from the client to the server:</p>
<pre class="plaintext"><code>&lt;Client&gt;                                              &lt;Server&gt;

[Closed]                                              [Closed]
                  SEQ=x     CTL=SYN               =&gt;
[SYN Sent]
              &lt;=  SEQ=y     CTL=SYN+ACK   ACK=x+1
                                                      [SYN Received]
                  SEQ=x+1   CTL=ACK       ACK=y+1 =&gt;
[Established]                                         [Established]</code></pre>
<h3 id="ip-security-issues">IP Security Issues</h3>
<ul>
<li>IP header doesn’t have confidentiality or integrity protection
<ul>
<li>Faking the sender address is easy to do</li>
<li>Traffic can be analyzed by sniffing packet headers</li>
</ul></li>
<li>IP payload doesn’t have confidentiality or integrity protection
<ul>
<li>Eavesdropping is possible by sniffing packets</li>
</ul></li>
<li>Loose coupling with lower layers:
<ul>
<li>Easy to divert traffic</li>
<li>Availability can be easily attacked</li>
<li>Confidentiality and integrity can’t be guaranteed</li>
</ul></li>
<li>Unprotected error signaling via ICMP: Fake error messages can affect availability</li>
<li>DNS is insecure; i.e. DNS spoofing</li>
</ul>
<h3 id="tcp-security-issues">TCP Security Issues</h3>
<ul>
<li>TCP header doesn’t have confidentiality or integrity protection</li>
<li>Session hijacking
<ul>
<li>When sniffing session details, attacker can impersonate a peer in a TCP connection</li>
<li>Attackers can guess session details and attack remotely using spoofed IP addresses</li>
</ul></li>
<li>RST attack: Attackers can reset/abort attacks by injecting packets with the RST flag</li>
<li>Port scanning
<ul>
<li>Find out open ports</li>
<li>Determine software running on port</li>
</ul></li>
<li>SYN flooding
<ul>
<li>Overload system resources by initializing many connections and not pursuing them</li>
</ul></li>
</ul>
<h3 id="port-scanning">Port Scanning</h3>
<ul>
<li>Objective: <strong>Collect information</strong>
<ul>
<li>Installed services</li>
<li>Software versions</li>
<li>OS</li>
<li>Firewall</li>
</ul></li>
<li>Enumeration based on port
<ul>
<li>Well-known ports (i.e. SSH → 22)</li>
<li>Invalid connection requests: Different way of error handling can be used to fingerprint the OS</li>
</ul></li>
<li>Possible scanning methods
<ul>
<li>TCP connect scan</li>
<li>Half-open scan</li>
<li>SYN-ACK scan</li>
<li>ACK scan</li>
</ul></li>
</ul>
<h3 id="tcp-protection-mechanisms">TCP Protection Mechanisms</h3>
<ul>
<li>SYN flood protection
<ul>
<li>Limit rate of SYN packets</li>
<li>SYN cookies (RFC 4987)
<ul>
<li>Limit resources</li>
<li>Half-open connections are not stored in the connection table but instead as a hash in the ISN</li>
<li>Only if the 3rd ACK handshake packet matches the sequence number, the connection is added to the connection table</li>
<li>Server does not need to maintain any state information on half-open connections: Resources can’t be exhausted</li>
</ul></li>
</ul></li>
<li>Connections are only accepted if the sequence numbers are within a certain range of acceptable values (attackers would have to sniff sequence numbers or guess them)</li>
</ul>
<h3 id="session-hijacking">Session Hijacking</h3>
<ul>
<li>Attacker takes over existing connection between two peers</li>
<li>Requirement: Attacker has to sniff or guess sequence numbers of the connection correctly</li>
</ul>
<h3 id="rst-attacks-in-connection-dos">RST Attacks (In-Connection DoS)</h3>
<p>Inject packet with RST flag into ongoing connection: Connection has to be aborted immediately</p>
<h3 id="blind-ip-spoofing">Blind IP Spoofing</h3>
<p>Firewall is configured to only allow one source IP address and destination IP address (A → B).</p>
<p>To circumvent this restriction:</p>
<ol type="1">
<li>Attackers starts DoS attack on A to prevent A from sending RST packets to B</li>
<li>Attacker sends TCP connection setup packet with A’s source IP address to B</li>
<li>B sends SYN+ACK packet to A, but can’t respond due to DoS</li>
<li>Attacker sends TCP connection ACK packet to B with ACK matching the initial sequence number chosen by B (which has to be guessed, as B sent the SYN+ACK packet to A, not the attacker)</li>
</ol>
<p>Only works if B uses a predicable algorithm for it’s ISN and packet filters aren’t in place.</p>
<h2 id="perimeter-defense-in-pratice">Perimeter Defense in Pratice</h2>
<h3 id="architecture-recommendations">Architecture Recommendations</h3>
<ul>
<li>Known from medieval cities, castles etc.</li>
<li>Definition of system boundary between “inside” and “outside”</li>
<li>Different threat models for inside and outside
<ul>
<li><strong>Inside</strong>: Trusted</li>
<li><strong>Outside</strong>: Untrusted</li>
</ul></li>
<li>Objectives
<ul>
<li>Create said boundary</li>
<li>Only a defined set of communication relations is allowed</li>
<li>Special security checks</li>
<li>Limited number of interconnection points</li>
<li>Simpler to manage and audit than a completely open architecture</li>
</ul></li>
<li>Problems
<ul>
<li>Requires intelligent selection of system boundaries</li>
<li>May require multiple levels of perimeters</li>
<li>No system/user in the “trusted inside” can truly be trusted</li>
</ul></li>
</ul>
<h3 id="application-in-networking">Application in Networking</h3>
<ul>
<li>Installing security devices at the network border</li>
<li>Seperation of network areas into inside/outside</li>
<li>Prevent sensistive information from being sent to the outside (view the system in the inside as the potential, probably unintentional attacker)</li>
<li>Multiple levels can increase security</li>
<li>But: Perimeter security is not sufficient on its own!
<ul>
<li>The will probably be additional non-secured paths into the network (i.e. <code>ssh -R</code>)</li>
<li>Some malicious traffic might look like “normal” traffic and can pass</li>
</ul></li>
</ul>
<h3 id="stateless-packet-filter">Stateless Packet Filter</h3>
<ul>
<li>Access Control List (ACL): Applies set of rules to each incoming packets</li>
<li>Discards (denies, blocks) or forwards (allows, permits) packets based on ACL</li>
<li>Typically configured by IP and TCP/UDP header fields</li>
<li>Stateless inspection: Established connections can only be detected with the ACK control flag</li>
<li>Can be easy to misconfigure by forgetting essential protocols
<ul>
<li>DNS</li>
<li>ICMP</li>
</ul></li>
<li>Advantages
<ul>
<li>Fast/High throughput</li>
<li>Simple to realize</li>
<li>Software-based, can be added as a package</li>
<li>Simple to configure</li>
</ul></li>
<li>Disadvantages
<ul>
<li>Inflexible</li>
<li>Many attacks can only be detected using stateful filtering</li>
<li>Rules and their priorities can easily get confusing</li>
</ul></li>
<li>Default discard policy
<ul>
<li>Block everything which is not explicitly allowed (allowlist)</li>
<li>Issue: The security policy has to be revised for each new protocol or service</li>
<li>This rule must come last/have the lowest priority, behind all “allowing” rules</li>
</ul></li>
</ul>
<h3 id="stateful-packet-filters">Stateful Packet Filters</h3>
<ul>
<li>Store connection states</li>
<li>Can make decisions based on
<ul>
<li>TCP connections</li>
<li>UDP replies to previous outgoing packet with same IP:Port relation (“UDP Connection”)</li>
<li>Application protocol states</li>
</ul></li>
<li>Similar to application layer gates/proxy firewalls, but less intruding in communication</li>
<li>Rules can be more specific than in stateless packet filters</li>
<li>Rules are easier to enforce, i.e. incoming TCP packets don’t have to be allowed in because they have ACK set</li>
</ul>
<h3 id="stateful-firewalls">Stateful Firewalls</h3>
<ul>
<li>Tries to fix the problems of stateless inspection
<ul>
<li>To many packets have to be allowed by default (ACK → No SYN-scanning protection)</li>
<li>Protocols like FTP or SIP, which dynamically allocate port numbers, can’t be filtered securely</li>
</ul></li>
<li>Create state per TCP or UDP flow
<ul>
<li>Source and Destination IP:Port</li>
<li>Protocol</li>
<li>Connection state</li>
</ul></li>
<li>A packet which is not associated with a state is dropped immediately</li>
<li>Packets which belong to a previously established TCP/UDP “connection” are allowed to pass without further checks</li>
<li>State tables have to be cleaned up periodically to prevent resource starvation</li>
</ul>
<h3 id="application-layer-proxies">Application Layer Proxies</h3>
<ul>
<li>Protected host during connection establishment</li>
<li>Different kinds
<ul>
<li>Application level</li>
<li>Circuit level</li>
<li>Forward proxy (client-side)</li>
<li>Reverse proxy (server-side)</li>
</ul></li>
</ul>
<h3 id="application-level-gateways">Application Level Gateways</h3>
<ul>
<li>Conversion between different application layer protocols</li>
<li>Evaluation up to OSI layer 7
<ul>
<li>Protocol verification</li>
<li>Authentication</li>
<li>Malware scanning</li>
<li>Spam filtering</li>
<li>Attack pattern filtering</li>
</ul></li>
<li>Advantage: Security policies can be enforced at application level</li>
<li>Disadvantage: Computing and memory performance requirements</li>
</ul>
<h3 id="demilitarized-zone-dmz">Demilitarized Zone (DMZ)</h3>
<ul>
<li><strong>Outside world</strong>: Global Internet</li>
<li><strong>Outside router</strong>: Routes packet to and from bastion host</li>
<li><strong>Bastian host</strong>: Proxy server and relay host</li>
<li><strong>Inside router</strong>: Routes packets only to and from bastion host</li>
<li><strong>Inside (protected)</strong>: Intranet</li>
</ul>
<p>The DMZ creates 2/3 lines of defense by the use of a stub network.</p>
<p>Multi-Level DMZs can create even more secure perimeter defenses:</p>
<p>Global Internet → Access Router and Packet Filter → Public Services Host (offers i.e. public Web services) → Screening Router and Packet filter (prevents IP spoofing) → Mail host (for external mail communication) → Bastion host (i.e. proxy for FTP and Web access) → Intranet</p>
<h3 id="web-application-firewalls-wafs">Web Application Firewalls (WAFs)</h3>
<ul>
<li>Acts on the application layer</li>
<li>Is a reverse prxoy</li>
<li>Can protect the web server from “evil” client input
<ul>
<li>Cross-Site scripting</li>
<li>SQL injection: Filters out JS or SQL commands in client input by removing special symbols (i.e. <code>&lt;</code>, <code>'</code> etc)</li>
<li>Cookie poisoning: Stores the hash values of sent cookies</li>
<li>HTML manipulation: Encypts URL parameters</li>
</ul></li>
</ul>
<h3 id="intrusion-detection-systems-ids">Intrusion Detection Systems (IDS)</h3>
<ul>
<li>Security product that is specialized on detecting anomalies during live operation of networks and computers
<ul>
<li>Virus/Botnet activity</li>
<li>Suspicious network activity (malware phoning home)</li>
</ul></li>
<li>Basic Approaches
<ul>
<li><strong>Signature based</strong>: Use attack signatures/known malicious communication activity patterns</li>
<li><strong>Anomaly based</strong>: Significant deviation from previously recorded baseline activity</li>
<li><strong>Rule based</strong>: Define allowed by behaviour by app-specific set of legitimate actions</li>
</ul></li>
<li>Actions
<ul>
<li>Send ut alarm</li>
<li>Logging</li>
<li>Blocking of known patters</li>
</ul></li>
<li>Realization
<ul>
<li>Appliance</li>
<li>Integration in firewall</li>
<li>Integration into host</li>
</ul></li>
</ul>
<h2 id="symmetric-encryption">Symmetric Encryption</h2>
<h3 id="symmetric-encryption-overview">Symmetric Encryption Overview</h3>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li>Creates message</li>
<li>Chooses key</li>
<li>Computes ciphertext</li>
<li>Send ciphertext to Bob</li>
</ol>
<p><strong>Eve</strong> (Attacker):</p>
<ol type="1">
<li>Copies ciphertext</li>
<li>Tries to guess the key</li>
</ol>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Receives ciphertext</li>
<li>Uses key</li>
<li>Computes plaintext</li>
<li>Reads message</li>
</ol>
<h3 id="kerckhoffs-principle">Kerckhoffs’ Principle</h3>
<ul>
<li>From “La Cryptographie Militaire”</li>
<li>Most important point: <strong>The security of a crypto system must lie in the non-disclosure of the key but not in the non-disclosure of the algorithm</strong></li>
<li>Implementation
<ul>
<li>Keep secret which function you used for encryption</li>
<li>But a disclosure of the set of functions should not create a problem</li>
</ul></li>
</ul>
<h3 id="strong-algorithms">Strong Algorithms</h3>
<ul>
<li>There is no attack that can break it with less effort than a brute force attack (“complete enumeration”)</li>
<li>There are so many keys that a complete search of key space is infeasable</li>
</ul>
<h3 id="crypto-attack-classes">Crypto Attack Classes</h3>
<ul>
<li><strong>Active</strong> attacks
<ul>
<li>Most relevant for cryptographic protocols</li>
<li>Active interference (modification, insertion or deletion of messages)</li>
<li>Man in the middle (MITM) can receive messages and modify them on the way to the receiver</li>
</ul></li>
<li><strong>Passive</strong> attacks: Pure eavesdropping, without interference with communication</li>
</ul>
<h3 id="perfect-security">Perfect Security</h3>
<p>Ciphertext does not give any information you don’t already have about the plaintext</p>
<h3 id="one-time-pad">One-Time-Pad</h3>
<ul>
<li><strong>Vernam Cypher</strong>: Create ciphertext by XOR addition of secret key and plaintext</li>
<li><strong>Mauborgne</strong>: Random key, never re-use key (“one time”)</li>
<li><strong>Shannon</strong>: OTP is unbreakable if key is …
<ul>
<li>Truly random</li>
<li>As large</li>
<li>Never reused</li>
<li>Kept secret</li>
</ul></li>
</ul>
<h3 id="stream-cyphers">Stream Cyphers</h3>
<p>Encryption like one-time-pad, but using pseudo-random bits instead of true random (using a <strong>Crytographically Secure Pseudo-Random Number Generator (CSPRNG)</strong>)</p>
<h3 id="cryptographically-secure-pseudo-random-number-generators-csprng">Cryptographically Secure Pseudo-Random Number Generators (CSPRNG)</h3>
<p>A CSPRNG must …</p>
<ul>
<li>Be unpredictable</li>
<li>Be computationally infeasible to compute the next outputs</li>
</ul>
<p>… when the initial state of the CSPRNG is not known</p>
<h3 id="design-principles-for-block-cyphers">Design Principles for Block Cyphers</h3>
<p>Two methods for frustrating a statistical analysis:</p>
<ul>
<li><strong>Confusion</strong>: The ciphertext should depend on the plaintext in such a complicated way that an attacker cannot gain any information from the ciphertext (redundancy should not be visible anymore in the ciphertext)</li>
<li><strong>Diffusion</strong>: Each plaintext and key bit should influence as many ciphertext bits as possible
<ul>
<li>Changing one bit in plaintext → Many pseudo-random changes in ciphertext</li>
<li>Changing one bit in the key → Many pseudo-random changes in ciphertext</li>
</ul></li>
</ul>
<h3 id="feistel-networks">Feistel Networks</h3>
<ul>
<li>Described by Horst Feistel</li>
<li>Algorithm
<ul>
<li>Plaintext block B is divided in 2 halves</li>
<li>Derive r round key keys from key</li>
<li>Feed one half through round function F</li>
<li>Then XOR the result with the other half</li>
<li>Exchange halves</li>
</ul></li>
<li>Repeat r times</li>
</ul>
<h3 id="des-tripple-des">DES (Tripple DES)</h3>
<ul>
<li>Single DES breakable in less than 24h (complete search of key space)</li>
<li>Tripple DES is still secure</li>
<li>Three steps of DES on each data block using up to three keys</li>
<li>Decryption in reverse sequence</li>
<li>3 independend keys are the most secure</li>
<li>Three same keys can be used for (insecure) DES compatibility</li>
</ul>
<h3 id="aes-key-features">AES Key Features</h3>
<ul>
<li>FIPS standard 197</li>
<li>Key length: 128/192/256 bit</li>
<li>Block size: 128 bit</li>
<li>Iterative rounds of substitutions and permutation, but no Feistel structure</li>
<li>10, 12 or 14 rounds</li>
<li>Blocks of 16 bytes arranged in 4x4 state matrix</li>
<li>Components of the round function are invertible and independent of key
<ul>
<li><strong>Substitute Bytes</strong>: Non-linear substitution of bytes in state</li>
<li><strong>Shift Rows</strong>: Cyclic shifting of rows</li>
<li><strong>Min Columns</strong>: Multiplication of state elements with a fixed 4x4 matrix M</li>
</ul></li>
</ul>
<h3 id="modes-of-operation-for-block-cyphers">Modes of Operation for Block Cyphers</h3>
<ul>
<li>Objective: Encrypt multiple plaintext blocks with the same block cypher</li>
<li>Straightforward solution: blockwise encryption (“Electronic Codebook Mode”)</li>
<li>Problem: Patterns in the distribution of plaintext blocks remain visible</li>
</ul>
<h3 id="cypher-block-chaining-cbc">Cypher Block Chaining (CBC)</h3>
<ul>
<li>Avoids telltale patterns in ciphertext</li>
<li>Decryption fails if a data block is missing or corrupted</li>
<li>Each data block is encrypted in relation to the previous block</li>
</ul>
<h3 id="counter-mode-ctr">Counter Mode (CTR)</h3>
<ul>
<li>Simple and efficient</li>
<li>Random access still possible</li>
<li>No issues if data block is missing</li>
<li>Incrementing counter is involved in randomization per data block</li>
</ul>
<h3 id="padding">Padding</h3>
<ul>
<li>Plaintext needs to be a full number of blocks</li>
<li>If plaintext does not fill the last block completely, it must be padded before encryption
<ul>
<li>In order to facilitate safe decryption, the last block is always padded: For example for a block size of n bytes, there are 1…n bytes added to the plaintext before encryption</li>
<li>Decryption can check last bytes and strip them off correspondingly</li>
</ul></li>
<li>Always need to pad with at least one byte!</li>
<li>Common methods
<ul>
<li>Pad with bytes of the same value as the number of padding bytes (PKCS#5; i.e. if there are three bytes to be padded, add <code>0x03 0x03 0x03</code>)</li>
<li>Pad with <code>0x80</code> followed by <code>0x00</code> bytes</li>
<li>Pad with zeroes except for the last byte that indicates the number of padding bytes</li>
<li>Pad with zeroes</li>
<li>Pad with space characters (<code>0x20</code>)</li>
</ul></li>
</ul>
<h3 id="key-length-considerations">Key Length Considerations</h3>
<ul>
<li>Cryptography is always a matter of complexity
<ul>
<li>With enough time and/or space, all schemes can theoretically be broken</li>
<li>“brute force” attacks</li>
<li>Example: 56bit keys DES can be broken in &lt;24h since 1999</li>
</ul></li>
<li>Meanwhile
<ul>
<li>128bit keys have to be replaced in the coming years</li>
<li>192bit keys are secure in medium term</li>
<li>256bit keys are hard to crack due to physical boundaries</li>
</ul></li>
<li>Quantum computers might be able to crack keys much more quickly</li>
<li>Numbers refer to unbroken algorithms in symmetric cryptography
<ul>
<li>Broken algorithm is one where an n bit key can be determined trying out significantly less than 2<sup>n</sup> keys</li>
</ul></li>
</ul>
<h2 id="message-authentication">Message Authentication</h2>
<h3 id="message-authentication-codes-macs">Message Authentication Codes (MACs)</h3>
<ul>
<li>Objectives
<ul>
<li><strong>Integrity protection</strong>: Prevent unauthorized manipulation of data</li>
<li><strong>Message authentication</strong>: Prevent unauthorized origination on behalf of others</li>
</ul></li>
<li>Idea: Compute a cryptographic chesum (MAC)</li>
<li>Required Properties
<ul>
<li>Cannot be counterfeited; without having the sender’s secret, it is to complex to …
<ul>
<li>Find another message matching the same MAC</li>
<li>Construct a suitable MAC for another message</li>
</ul></li>
<li>Even smallest changes to message cause a big change of the MAC</li>
</ul></li>
</ul>
<h3 id="general-scenario">General Scenario</h3>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li><code>m = "I love you. Alice"</code></li>
<li>Select secret key <span class="math inline"><em>K</em></span></li>
<li>Compute <span class="math inline"><em>M</em><em>A</em><em>C</em><sub><em>K</em></sub>(<em>m</em>)</span></li>
</ol>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Receives <code>m'</code></li>
<li>Selects secret key <span class="math inline"><em>K</em></span></li>
<li>Computes <span class="math inline"><em>M</em><em>A</em><em>C</em><sub><em>K</em></sub>(<em>m</em>′)</span></li>
<li>Compares computed MAC with received MAC → Matches!</li>
</ol>
<p><strong>Assertion</strong>: If computed MAC equals the MAC included in the received message, an owner of the key (Alice) really sent this message and it was not changed on the way.</p>
<h3 id="scenario-with-modified-message">Scenario with Modified Message</h3>
<p><strong>Alice</strong>: Same as in <a href="#general-scenario">General Scenario</a></p>
<p><strong>Mallory</strong>:</p>
<ul>
<li><code>m = "It's all over! Alice."</code></li>
</ul>
<p><strong>Bob</strong></p>
<ol type="1">
<li>Receives <code>m'</code></li>
<li>Selects secret key <span class="math inline"><em>K</em></span></li>
<li>Computes <span class="math inline"><em>M</em><em>A</em><em>C</em><sub><em>K</em></sub>(<em>m</em>′)</span></li>
<li>Compares computed MAC with received MAC → Doesn’t match!</li>
<li>Ignore <code>m</code></li>
</ol>
<h3 id="mac-computation">MAC Computation</h3>
<ul>
<li>Requirements
<ul>
<li>Shared key k between sender and receiver</li>
<li>Hash function to create a code that changes if the message has been altered</li>
</ul></li>
<li>Using <strong>block cypher</strong> <span class="math inline"><em>f</em><sub><em>k</em></sub></span> and <strong>hash function</strong> <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span>: <span class="math inline"><em>M</em><em>A</em><em>C</em>(<em>m</em>) = <em>f</em><sub><em>k</em></sub>(<em>h</em><em>a</em><em>s</em><em>h</em>(<em>m</em>))</span></li>
<li>Using a <strong>key dependent cryptographic hash function</strong> <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>k</em>,<em>m</em>)</span>: <span class="math inline"><em>M</em><em>A</em><em>C</em>(<em>m</em>) = <em>h</em><em>a</em><em>s</em><em>h</em>(<em>k</em>,<em>m</em>)</span></li>
</ul>
<h3 id="hash-function-requirements">Hash Function Requirements</h3>
<ul>
<li>Weak <strong>collision resistance</strong>: For a given message and hash it is impossible/to complex to find another message such that the hashes match</li>
<li><strong>One-way</strong> property
<ul>
<li>Easy to compute hash</li>
<li>Impossible to find message from hash</li>
</ul></li>
</ul>
<h2 id="asymmetric-encryption">Asymmetric Encryption</h2>
<h3 id="public-key-cryptography">Public Key Cryptography</h3>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li>Generates key pair <span class="math inline">(<em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>,<em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>)</span></li>
<li>Published <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> at Trent’s</li>
<li><span class="math inline"><em>c</em></span> received → decrypts <span class="math inline"><em>m</em> = <em>D</em><sub><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>C</em>)</span></li>
</ol>
<p><strong>Trent</strong>:</p>
<ul>
<li>Stores public keys</li>
<li>Provides public keys on request</li>
</ul>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Wants to send <span class="math inline"><em>m</em></span> to Alice confidentially</li>
<li>Obtains <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> from Trent</li>
<li>Computes <span class="math inline"><em>c</em> = <em>E</em><sub><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>m</em>)</span></li>
<li>Sends <span class="math inline"><em>c</em></span> to Alice</li>
</ol>
<h3 id="rsa-key-generation">RSA Key Generation</h3>
<ol type="1">
<li>Alice chooses 2 large prime numbers <span class="math inline"><em>p</em>, <em>q</em></span> and computes <span class="math inline"><em>n</em> = <em>p</em> ⋅ <em>q</em></span>, <span class="math inline"><em>ϕ</em>(<em>n</em>) = (<em>p</em>−1)(<em>q</em>−1)</span></li>
<li>Alice chooses an integer <span class="math inline"><em>e</em></span> with <span class="math inline">1 &lt; <em>e</em> &lt; <em>ϕ</em>(<em>n</em>)</span> that is relatively prime to <span class="math inline"><em>ϕ</em>(<em>n</em>)</span></li>
<li>Alice computes an integer <span class="math inline"><em>d</em></span> with <span class="math inline">1 &lt; <em>d</em> &lt; <em>ϕ</em>(<em>n</em>)</span> and <span class="math inline"><em>d</em> ⋅ <em>e</em> = <em>k</em> ⋅ <em>ϕ</em>(<em>n</em>) + 1</span></li>
<li>Alice publishes her public key <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub> = (<em>e</em>,)</span></li>
<li>Alice keeps her private key <span class="math inline"><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub> = <em>d</em></span> and <span class="math inline"><em>p</em></span>, <span class="math inline"><em>q</em></span>, <span class="math inline"><em>ϕ</em>(<em>n</em>)</span> secret</li>
</ol>
<h3 id="rsa-encryption">RSA Encryption</h3>
<ol type="1">
<li>Bob obtains <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub> = (<em>e</em>,<em>n</em>)</span></li>
<li>Bob composes plaintext <span class="math inline"><em>m</em> ∈ <em>M</em> = {1, 2, ..., <em>n</em> − 1}</span></li>
<li>Bob computes the ciphertext <span class="math inline"><em>c</em> = <em>E</em><sub><em>P</em><em>K</em><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>(<em>m</em>) = <em>m</em><sup><em>e</em></sup> mod  <em>n</em></span></li>
<li>Bob sends <span class="math inline"><em>c</em></span> to Alice</li>
</ol>
<h3 id="rsa-decryption">RSA Decryption</h3>
<p>Alice can obtain the plaintext message <span class="math inline"><em>m</em></span> by computing <span class="math inline"><em>m</em> = <em>D</em><sub><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>c</em>) = <em>c</em><sup><em>d</em></sup> mod  <em>n</em> = <em>m</em><sup><em>e</em><em>d</em></sup> mod  <em>n</em></span></p>
<h3 id="rsa-security">RSA Security</h3>
<ul>
<li><strong>RSA problem</strong>: Given <span class="math inline"><em>e</em></span>, <span class="math inline"><em>n</em></span> and <span class="math inline"><em>c</em> = <em>m</em><sup><em>e</em></sup> mod  <em>n</em></span>, find <span class="math inline"><em>m</em></span>
<ul>
<li>Most efficient approach to solve the RSA problem is currently the integer factorization of <span class="math inline"><em>n</em></span>: An upper limit to the complexity of the problem; can be used to derive the private key from the prime factors</li>
<li>Quantum computers will be more efficient in doing integer factorization (Shor’s algorithm)</li>
<li>RSA problem and integer factorization still lack mathematical proof for their complexity</li>
</ul></li>
<li><strong>Organizational properties</strong>
<ul>
<li><strong>Authenticity</strong> of the public key <span class="math inline">(<em>e</em>,<em>n</em>)</span></li>
<li><strong>Confidentiality</strong> of the secret key <span class="math inline">(<em>d</em>,<em>p</em>,<em>q</em>)</span></li>
</ul></li>
<li><strong>Mathematical properties</strong>
<ul>
<li><strong>Complexity of factoring</strong> the modulus <span class="math inline"><em>n</em></span></li>
<li><strong>Complexity of solving</strong> the RSA problem</li>
</ul></li>
<li>Failure of any properties will compromise the security of the method!</li>
</ul>
<h3 id="hybrid-method">Hybrid Method</h3>
<p>Combination of asymmetric and symmetric key methods.</p>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li>Generates key pair <span class="math inline">(<em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>,<em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>)</span></li>
<li>Publishes <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> at Trent’s</li>
<li><span class="math inline"><em>c</em></span> received → Decrypts <span class="math inline"><em>K</em> = <em>D</em><sub><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>c</em>)</span></li>
<li>Alice and bob switch over to the symmetric key algorithm with key <span class="math inline"><em>K</em></span></li>
</ol>
<p><strong>Trent</strong>:</p>
<ul>
<li>Stores public keys</li>
<li>Provides public keys on request</li>
</ul>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Obtains <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> from Trent</li>
<li>Generates symmetric key <span class="math inline"><em>K</em></span></li>
<li>Computes <span class="math inline"><em>c</em> = <em>E</em><sub><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>K</em>)</span></li>
<li>Sends <span class="math inline"><em>c</em></span> to Alice</li>
</ol>
<h3 id="discrete-logarithms">Discrete Logarithms</h3>
<p><strong>Primitive element</strong>: Let <span class="math inline"><em>p</em></span> be a prime number. An element <span class="math inline"><em>g</em> ≤ <em>p</em> − 1</span> is called primitive element <span class="math inline"> mod  <em>p</em></span> if for each <span class="math inline"><em>A</em> ∈ {1, 2, ..., <em>p</em> − 1}</span> there is an <span class="math inline"><em>x</em></span> such that <span class="math inline"><em>A</em> = <em>g</em><sup><em>x</em></sup> mod  <em>p</em></span></p>
<p><strong>Discrete logarithm</strong>: Let <span class="math inline"><em>p</em></span> be a prime number and let <span class="math inline"><em>g</em> ≤ <em>p</em> − 1</span> be a primitive element <span class="math inline"> mod  <em>p</em></span>. Then an element <span class="math inline"><em>x</em></span> is called discrete logarithm of <span class="math inline"><em>A</em></span> to base <span class="math inline"><em>g</em> mod  <em>p</em></span> if <span class="math inline"><em>A</em> = <em>g</em><sup><em>x</em></sup> mod  <em>p</em></span>.</p>
<p><strong>Discrete logarithm problem</strong>: Given <span class="math inline"><em>A</em></span>, <span class="math inline"><em>g</em></span>, <span class="math inline"><em>p</em></span>, find <span class="math inline"><em>x</em> ≤ <em>p</em> − 1</span> with <span class="math inline"><em>A</em> = <em>g</em><sup><em>x</em></sup> mod  <em>p</em></span></p>
<h3 id="one-way-functions">One-Way Functions</h3>
<ul>
<li>“Trap-door” functions</li>
<li>Easy to compute in one direction (i.e. <span class="math inline"><em>f</em>(<em>x</em>) = <em>g</em><sup><em>x</em></sup> mod  <em>p</em></span>)</li>
<li>Hard to invert
<ul>
<li>Ideally only possible using complete enumeration of all possible inputs</li>
<li>I.e. for a given <span class="math inline"><em>y</em></span> you need to try out all possible values <span class="math inline"><em>x</em> = 0, 1, ..., <em>p</em> − 1</span> to find one <span class="math inline"><em>x</em><sub>0</sub> : <em>f</em>(<em>x</em><sub>0</sub>) = <em>y</em></span></li>
</ul></li>
<li>Definition of complexity often of the P and NP complexity classes
<ul>
<li><strong>P</strong>: Answer of a problem can be found in polynomial time (<span class="math inline"><em>b</em></span> bits of problem size → algorithm takes time <span class="math inline"><em>b</em><sup><em>k</em></sup></span>)</li>
<li><strong>NP</strong>: Answer of problem cannot be found in polynomial time (<span class="math inline"><em>b</em></span> bits of problem size → algorithm takes time <span class="math inline"><em>k</em><sup><em>b</em></sup></span>), but the correctness of given answer can be checked in polynomial time</li>
</ul></li>
</ul>
<h3 id="diffie-hellman-key-exchange-protocol">Diffie-Hellman Key Exchange Protocol</h3>
<p><strong>Purpose</strong>: Allow communication partners without prior knowledge of another to establish a shared secret key over an insecure communication channel</p>
<ol type="1">
<li>Alice and Bob agree publicly on prime number <span class="math inline"><em>p</em></span> and a primitive element <span class="math inline"><em>g</em> ≤ <em>p</em> − 1</span></li>
<li>Alice randomly chooses <span class="math inline"><em>α</em> ∈ {2, ..., <em>p</em> − 2}</span> and computes <span class="math inline"><em>A</em> = <em>g</em><sup><em>α</em></sup> mod  <em>p</em></span></li>
<li>Bob randomly chooses <span class="math inline"><em>β</em> ∈ {2, ..., <em>p</em> − 2}</span> and computes <span class="math inline"><em>B</em> = <em>g</em><sup><em>β</em></sup> mod  <em>p</em></span></li>
<li>Alice and Bob publicly exchange A and B</li>
<li>Alice and Bob hold a common secret key <span class="math inline"><em>K</em></span>:
<ol type="1">
<li><span class="math inline"><em>K</em><sub><em>B</em></sub> = <em>A</em><sup><em>β</em></sup> mod  <em>p</em> = <em>g</em><sup><em>α</em><em>β</em></sup> mod  <em>p</em></span></li>
<li><span class="math inline"><em>K</em><sub><em>A</em></sub> = <em>B</em><sup><em>α</em></sup> mod  <em>p</em> = <em>g</em><sup><em>α</em><em>β</em></sup> mod  <em>p</em> = <em>K</em><sub><em>B</em></sub></span></li>
</ol></li>
</ol>
<h3 id="diffie-hellman-key-exchange-protocol-security">Diffie-Hellman Key Exchange Protocol Security</h3>
<p>It depends on three properties which can’t be relaxed:</p>
<ul>
<li><strong>Discrete logarithm problem</strong>: There is no efficient inversion for integer exponentiation</li>
<li><strong>Authenticity</strong> of exchanged messages: No protection against MITM attacks!</li>
<li><strong>Diffie-Hellman problem complexity</strong>: Given <span class="math inline"><em>g</em>, <em>p</em>, <em>A</em> = <em>g</em><sup><em>x</em></sup> mod  <em>p</em>, <em>B</em> = <em>g</em><sup><em>y</em></sup> mod  <em>p</em></span> find <span class="math inline"><em>K</em> = <em>g</em><sup><em>x</em><em>y</em></sup> mod  <em>p</em></span></li>
</ul>
<h3 id="digital-signatures">Digital Signatures</h3>
<ul>
<li>Requirements
<ul>
<li><strong>Tamper-proof</strong></li>
<li><strong>Unambiguous attribution</strong> of signature to signing person/identity</li>
<li><strong>Inseparable connection</strong> between signature and signed document</li>
<li><strong>Non-repudiability</strong> of signature</li>
</ul></li>
<li>Typical approach
<ul>
<li>Encrypt hash of document with secret key</li>
<li>Signature can be verified using the public key</li>
</ul></li>
</ul>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li>Generates key pair <span class="math inline">(<em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>,<em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>)</span></li>
<li>Publishes <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> at Trent’s</li>
<li>Computes <span class="math inline"><em>s</em><em>i</em><em>g</em><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em>(<em>m</em>) = <em>E</em><sub><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>h</em><em>a</em><em>s</em><em>h</em>(<em>m</em>))</span></li>
</ol>
<p><strong>Trent</strong>:</p>
<ul>
<li>Stores public keys</li>
<li>Provides public keys on request</li>
</ul>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Obtains <span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></span> from Trent</li>
<li>Computes <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>m</em><sub><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em><em>d</em></sub>)</span></li>
<li>Decrypts signature <span class="math inline"><em>D</em><sub><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub></sub>(<em>s</em><em>i</em><em>g</em><sub><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em><em>d</em></sub>)</span></li>
<li>Compares <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>m</em><sub><em>r</em><em>e</em><em>c</em><em>e</em><em>i</em><em>v</em><em>e</em><em>d</em></sub>)</span> to the received signed hash</li>
</ol>
<h3 id="rsa-signatures">RSA Signatures</h3>
<ul>
<li>Conventions
<ul>
<li><span class="math inline"><em>P</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub> = (<em>e</em>,<em>n</em>)</span></li>
<li><span class="math inline"><em>S</em><em>K</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub> = <em>d</em></span></li>
<li><span class="math inline"><em>m</em></span> is the message to be signed</li>
<li><span class="math inline"><em>h</em></span> is the secure hash function</li>
</ul></li>
<li><strong>Computation</strong> of signature: <span class="math inline"><em>s</em><em>i</em><em>g</em><sub><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></sub>(<em>m</em>) = (<em>h</em>(<em>m</em>))<sup><em>d</em></sup> mod  <em>n</em></span></li>
<li><strong>Verification</strong> of signature
<ul>
<li>Bob receives <span class="math inline">(<em>m</em>′,<em>s</em><em>i</em><em>g</em>′)</span></li>
<li>Bob computes <span class="math inline"><em>h</em>(<em>m</em>′)</span> and <span class="math inline">(<em>s</em><em>i</em><em>g</em>′)<sup><em>e</em></sup> mod  <em>n</em></span></li>
<li>If both match, the signature is verified</li>
</ul></li>
</ul>
