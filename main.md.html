<h1 id="uni-it-security-notes">Uni IT Security Notes</h1>
<h2 id="basics">Basics</h2>
<h3 id="security-mindset">Security Mindset</h3>
<ul>
<li>Focus on weaknesses, not on features</li>
<li>Don’t rely on the “good case”</li>
<li>Anticipate what an attacker could do to a system</li>
<li>Weight security against user experience and privacy</li>
</ul>
<h3 id="security-objectives">Security Objectives</h3>
<ul>
<li><strong>Confidentiality</strong>/<code>conf</code>
<ul>
<li>Nobody but the legitimate receiver can read a message</li>
<li>Third party cannot gain access to communication patterns</li>
</ul></li>
<li><strong>Integrity</strong>/<code>int</code>: The contents of communication can’t be changed</li>
<li><strong>Authenticity</strong>/<code>authN</code>
<ul>
<li><strong>Entity Authentication</strong>: Communication partners can prove their respective identity to one another</li>
<li><strong>Message Authentication</strong>: It can be verified that a message is authentic (unaltered and sent by the correct entity)</li>
</ul></li>
<li><strong>Authorization</strong>/<code>authZ</code>
<ul>
<li>Service or information is only available to those who have correct access rights</li>
<li>Depends on authentication being set up</li>
</ul></li>
<li><strong>Non-Repudiation</strong>/<code>nRep</code>: A sender cannot deny having sent a message or used a service</li>
<li><strong>Availability</strong>/<code>avail</code>: Service is available with sufficient performance</li>
<li><strong>Access Control</strong>/<code>ac</code>: Access to services and information is controlled</li>
<li><strong>Privacy</strong>/<code>priv</code>
<ul>
<li>Restricted access to identity-related data</li>
<li>Anonymity</li>
<li>Pseudonymity</li>
</ul></li>
</ul>
<h3 id="attacks-threats-and-vulnerabilities">Attacks, Threats and Vulnerabilities</h3>
<ul>
<li><strong>Attacker</strong>: A person who has the skill and motivation to carry out an attack: The steps needed to carry out an attack</li>
<li><strong>Vulnerability</strong>: Some characteristics of the target that can result in a security breach</li>
<li><strong>Threat</strong>: Combination of an attacker, an attack vector and a vulnerability</li>
<li><strong>Attack</strong>: A threat that has been realized and has caused a security breach</li>
</ul>
<h3 id="threat-identification">Threat Identification</h3>
<ul>
<li>Define <strong>system boundaries</strong>: What is part of your system, what is not?</li>
<li>Define <strong>security objectives</strong>: What is important for your system to be secure?</li>
<li><strong>List all threats</strong> you can think of: Brainstorming and discussion with experts</li>
<li>Use <strong>conventions</strong>:
<ul>
<li>Similar threat models</li>
<li>Requirement specifications</li>
<li>How to break or circumvent the specifications</li>
<li>Note security assumptions of the system</li>
<li>Be careful with perimeter security: What if perimeter has been breached?</li>
<li>Note <em>possible</em>, but not yet exploitable vulnerabilities</li>
</ul></li>
</ul>
<h2 id="security-frameworks">Security Frameworks</h2>
<h3 id="network-specific-threat-examples">Network Specific Threat Examples</h3>
<ul>
<li>Remote Attacks</li>
<li>Eavesdropping: Sniffing of information</li>
<li>Altering information</li>
<li>Spoofing</li>
<li>DoS</li>
<li>Session hijacking</li>
<li>Viruses attacking clients</li>
<li>Spam</li>
<li>Phishing</li>
<li>Data trails/privacy leaks</li>
</ul>
<h3 id="stride-attacks-on-a-multi-user-system">STRIDE: Attacks on a Multi-User System</h3>
<ul>
<li><strong>S</strong>poofing of Identity</li>
<li><strong>T</strong>ampering with Information</li>
<li><strong>R</strong>epudiation</li>
<li><strong>I</strong>nformation Disclosure</li>
<li><strong>D</strong>oS</li>
<li><strong>E</strong>scalation of Privileges</li>
</ul>
<h3 id="security-policies">Security policies</h3>
<ul>
<li>Classification of system states into “allowed” and “forbidden” states</li>
<li>Secure system: Is only in allowed states</li>
<li>Breached system: Is in forbidden state</li>
</ul>
<h2 id="malware">Malware</h2>
<ul>
<li>Performs unwanted functions</li>
<li>Often runs without user’s consent</li>
<li>Telemetry (often hidden in proprietary software behind EULAs)</li>
<li>Backdoors</li>
</ul>
<h2 id="networking">Networking</h2>
<h3 id="tcp-overview">TCP Overview</h3>
<ul>
<li>Characteristics
<ul>
<li>Reliable</li>
<li>Connection-Oriented</li>
<li>Full-Duplex</li>
<li>Layer atop IP</li>
<li>Connection management: Setup, Release and Abort</li>
<li>Ordered delivery (package sequence control)</li>
<li>Repetition of lost packets</li>
<li>End-to-End ACKs</li>
<li>Checksum in header</li>
</ul></li>
<li>Identified by a 5-tuple
<ul>
<li>Source IP</li>
<li>Destination IP</li>
<li>Transport Protocol</li>
<li>Source Port</li>
<li>Destination Port</li>
</ul></li>
</ul>
<h3 id="tcp-connection-establishment">TCP Connection Establishment</h3>
<ul>
<li>Virtual connection between two systems</li>
<li>3-Way-Handshake with connection states</li>
</ul>
<p>An example connection from the client to the server:</p>
<pre class="plaintext"><code>&lt;Client&gt;                                              &lt;Server&gt;

[Closed]                                              [Closed]
                  SEQ=x     CTL=SYN               =&gt;
[SYN Sent]
              &lt;=  SEQ=y     CTL=SYN+ACK   ACK=x+1
                                                      [SYN Received]
                  SEQ=x+1   CTL=ACK       ACK=y+1 =&gt;
[Established]                                         [Established]</code></pre>
<h3 id="ip-security-issues">IP Security Issues</h3>
<ul>
<li>IP header doesn’t have confidentiality or integrity protection
<ul>
<li>Faking the sender address is easy to do</li>
<li>Traffic can be analyzed by sniffing packet headers</li>
</ul></li>
<li>IP payload doesn’t have confidentiality or integrity protection
<ul>
<li>Eavesdropping is possible by sniffing packets</li>
</ul></li>
<li>Loose coupling with lower layers:
<ul>
<li>Easy to divert traffic</li>
<li>Availability can be easily attacked</li>
<li>Confidentiality and integrity can’t be guaranteed</li>
</ul></li>
<li>Unprotected error signaling via ICMP: Fake error messages can affect availability</li>
<li>DNS is insecure; i.e. DNS spoofing</li>
</ul>
<h3 id="tcp-security-issues">TCP Security Issues</h3>
<ul>
<li>TCP header doesn’t have confidentiality or integrity protection</li>
<li>Session hijacking
<ul>
<li>When sniffing session details, attacker can impersonate a peer in a TCP connection</li>
<li>Attackers can guess session details and attack remotely using spoofed IP addresses</li>
</ul></li>
<li>RST attack: Attackers can reset/abort attacks by injecting packets with the RST flag</li>
<li>Port scanning
<ul>
<li>Find out open ports</li>
<li>Determine software running on port</li>
</ul></li>
<li>SYN flooding
<ul>
<li>Overload system resources by initializing many connections and not pursuing them</li>
</ul></li>
</ul>
<h3 id="port-scanning">Port Scanning</h3>
<ul>
<li>Objective: <strong>Collect information</strong>
<ul>
<li>Installed services</li>
<li>Software versions</li>
<li>OS</li>
<li>Firewall</li>
</ul></li>
<li>Enumeration based on port
<ul>
<li>Well-known ports (i.e. SSH → 22)</li>
<li>Invalid connection requests: Different way of error handling can be used to fingerprint the OS</li>
</ul></li>
<li>Possible scanning methods
<ul>
<li>TCP connect scan</li>
<li>Half-open scan</li>
<li>SYN-ACK scan</li>
<li>ACK scan</li>
</ul></li>
</ul>
<h3 id="tcp-protection-mechanisms">TCP Protection Mechanisms</h3>
<ul>
<li>SYN flood protection
<ul>
<li>Limit rate of SYN packets</li>
<li>SYN cookies (RFC 4987)
<ul>
<li>Limit resources</li>
<li>Half-open connections are not stored in the connection table but instead as a hash in the ISN</li>
<li>Only if the 3rd ACK handshake packet matches the sequence number, the connection is added to the connection table</li>
<li>Server does not need to maintain any state information on half-open connections: Resources can’t be exhausted</li>
</ul></li>
</ul></li>
<li>Connections are only accepted if the sequence numbers are within a certain range of acceptable values (attackers would have to sniff sequence numbers or guess them)</li>
</ul>
<h3 id="session-hijacking">Session Hijacking</h3>
<ul>
<li>Attacker takes over existing connection between two peers</li>
<li>Requirement: Attacker has to sniff or guess sequence numbers of the connection correctly</li>
</ul>
<h3 id="rst-attacks-in-connection-dos">RST Attacks (In-Connection DoS)</h3>
<p>Inject packet with RST flag into ongoing connection: Connection has to be aborted immediately</p>
<h3 id="blind-ip-spoofing">Blind IP Spoofing</h3>
<p>Firewall is configured to only allow one source IP address and destination IP address (A → B).</p>
<p>To circumvent this restriction:</p>
<ol type="1">
<li>Attackers starts DoS attack on A to prevent A from sending RST packets to B</li>
<li>Attacker sends TCP connection setup packet with A’s source IP address to B</li>
<li>B sends SYN+ACK packet to A, but can’t respond due to DoS</li>
<li>Attacker sends TCP connection ACK packet to B with ACK matching the initial sequence number chosen by B (which has to be guessed, as B sent the SYN+ACK packet to A, not the attacker)</li>
</ol>
<p>Only works if B uses a predicable algorithm for it’s ISN and packet filters aren’t in place.</p>
<h2 id="perimeter-defense-in-pratice">Perimeter Defense in Pratice</h2>
<h3 id="architecture-recommendations">Architecture Recommendations</h3>
<ul>
<li>Known from medieval cities, castles etc.</li>
<li>Definition of system boundary between “inside” and “outside”</li>
<li>Different threat models for inside and outside
<ul>
<li><strong>Inside</strong>: Trusted</li>
<li><strong>Outside</strong>: Untrusted</li>
</ul></li>
<li>Objectives
<ul>
<li>Create said boundary</li>
<li>Only a defined set of communication relations is allowed</li>
<li>Special security checks</li>
<li>Limited number of interconnection points</li>
<li>Simpler to manage and audit than a completely open architecture</li>
</ul></li>
<li>Problems
<ul>
<li>Requires intelligent selection of system boundaries</li>
<li>May require multiple levels of perimeters</li>
<li>No system/user in the “trusted inside” can truly be trusted</li>
</ul></li>
</ul>
<h3 id="application-in-networking">Application in Networking</h3>
<ul>
<li>Installing security devices at the network border</li>
<li>Seperation of network areas into inside/outside</li>
<li>Prevent sensistive information from being sent to the outside (view the system in the inside as the potential, probably unintentional attacker)</li>
<li>Multiple levels can increase security</li>
<li>But: Perimeter security is not sufficient on its own!
<ul>
<li>The will probably be additional non-secured paths into the network (i.e. <code>ssh -R</code>)</li>
<li>Some malicious traffic might look like “normal” traffic and can pass</li>
</ul></li>
</ul>
<h3 id="stateless-packet-filter">Stateless Packet Filter</h3>
<ul>
<li>Access Control List (ACL): Applies set of rules to each incoming packets</li>
<li>Discards (denies, blocks) or forwards (allows, permits) packets based on ACL</li>
<li>Typically configured by IP and TCP/UDP header fields</li>
<li>Stateless inspection: Established connections can only be detected with the ACK control flag</li>
<li>Can be easy to misconfigure by forgetting essential protocols
<ul>
<li>DNS</li>
<li>ICMP</li>
</ul></li>
<li>Advantages
<ul>
<li>Fast/High throughput</li>
<li>Simple to realize</li>
<li>Software-based, can be added as a package</li>
<li>Simple to configure</li>
</ul></li>
<li>Disadvantages
<ul>
<li>Inflexible</li>
<li>Many attacks can only be detected using stateful filtering</li>
<li>Rules and their priorities can easily get confusing</li>
</ul></li>
<li>Default discard policy
<ul>
<li>Block everything which is not explicitly allowed (allowlist)</li>
<li>Issue: The security policy has to be revised for each new protocol or service</li>
<li>This rule must come last/have the lowest priority, behind all “allowing” rules</li>
</ul></li>
</ul>
<h3 id="stateful-packet-filters">Stateful Packet Filters</h3>
<ul>
<li>Store connection states</li>
<li>Can make decisions based on
<ul>
<li>TCP connections</li>
<li>UDP replies to previous outgoing packet with same IP:Port relation (“UDP Connection”)</li>
<li>Application protocol states</li>
</ul></li>
<li>Similar to application layer gates/proxy firewalls, but less intruding in communication</li>
<li>Rules can be more specific than in stateless packet filters</li>
<li>Rules are easier to enforce, i.e. incoming TCP packets don’t have to be allowed in because they have ACK set</li>
</ul>
<h3 id="stateful-firewalls">Stateful Firewalls</h3>
<ul>
<li>Tries to fix the problems of stateless inspection
<ul>
<li>To many packets have to be allowed by default (ACK → No SYN-scanning protection)</li>
<li>Protocols like FTP or SIP, which dynamically allocate port numbers, can’t be filtered securely</li>
</ul></li>
<li>Create state per TCP or UDP flow
<ul>
<li>Source and Destination IP:Port</li>
<li>Protocol</li>
<li>Connection state</li>
</ul></li>
<li>A packet which is not associated with a state is dropped immediately</li>
<li>Packets which belong to a previously established TCP/UDP “connection” are allowed to pass without further checks</li>
<li>State tables have to be cleaned up periodically to prevent resource starvation</li>
</ul>
<h3 id="application-layer-proxies">Application Layer Proxies</h3>
<ul>
<li>Protected host during connection establishment</li>
<li>Different kinds
<ul>
<li>Application level</li>
<li>Circuit level</li>
<li>Forward proxy (client-side)</li>
<li>Reverse proxy (server-side)</li>
</ul></li>
</ul>
<h3 id="application-level-gateways">Application Level Gateways</h3>
<ul>
<li>Conversion between different application layer protocols</li>
<li>Evaluation up to OSI layer 7
<ul>
<li>Protocol verification</li>
<li>Authentication</li>
<li>Malware scanning</li>
<li>Spam filtering</li>
<li>Attack pattern filtering</li>
</ul></li>
<li>Advantage: Security policies can be enforced at application level</li>
<li>Disadvantage: Computing and memory performance requirements</li>
</ul>
<h3 id="demilitarized-zone-dmz">Demilitarized Zone (DMZ)</h3>
<ul>
<li><strong>Outside world</strong>: Global Internet</li>
<li><strong>Outside router</strong>: Routes packet to and from bastion host</li>
<li><strong>Bastian host</strong>: Proxy server and relay host</li>
<li><strong>Inside router</strong>: Routes packets only to and from bastion host</li>
<li><strong>Inside (protected)</strong>: Intranet</li>
</ul>
<p>The DMZ creates 2/3 lines of defense by the use of a stub network.</p>
<p>Multi-Level DMZs can create even more secure perimeter defenses:</p>
<p>Global Internet → Access Router and Packet Filter → Public Services Host (offers i.e. public Web services) → Screening Router and Packet filter (prevents IP spoofing) → Mail host (for external mail communication) → Bastion host (i.e. proxy for FTP and Web access) → Intranet</p>
<h3 id="web-application-firewalls-wafs">Web Application Firewalls (WAFs)</h3>
<ul>
<li>Acts on the application layer</li>
<li>Is a reverse prxoy</li>
<li>Can protect the web server from “evil” client input
<ul>
<li>Cross-Site scripting</li>
<li>SQL injection: Filters out JS or SQL commands in client input by removing special symbols (i.e. <code>&lt;</code>, <code>'</code> etc)</li>
<li>Cookie poisoning: Stores the hash values of sent cookies</li>
<li>HTML manipulation: Encypts URL parameters</li>
</ul></li>
</ul>
<h3 id="intrusion-detection-systems-ids">Intrusion Detection Systems (IDS)</h3>
<ul>
<li>Security product that is specialized on detecting anomalies during live operation of networks and computers
<ul>
<li>Virus/Botnet activity</li>
<li>Suspicious network activity (malware phoning home)</li>
</ul></li>
<li>Basic Approaches
<ul>
<li><strong>Signature based</strong>: Use attack signatures/known malicious communication activity patterns</li>
<li><strong>Anomaly based</strong>: Significant deviation from previously recorded baseline activity</li>
<li><strong>Rule based</strong>: Define allowed by behaviour by app-specific set of legitimate actions</li>
</ul></li>
<li>Actions
<ul>
<li>Send ut alarm</li>
<li>Logging</li>
<li>Blocking of known patters</li>
</ul></li>
<li>Realization
<ul>
<li>Appliance</li>
<li>Integration in firewall</li>
<li>Integration into host</li>
</ul></li>
</ul>
<h2 id="encryption">Encryption</h2>
<h3 id="symmetric-encryption">Symmetric Encryption</h3>
<p><strong>Alice</strong>:</p>
<ol type="1">
<li>Creates message</li>
<li>Chooses key</li>
<li>Computes cyphertext</li>
<li>Send cyphertext to Bob</li>
</ol>
<p><strong>Eve</strong> (Attacker):</p>
<ol type="1">
<li>Copies cyphertext</li>
<li>Tries to guess the key</li>
</ol>
<p><strong>Bob</strong>:</p>
<ol type="1">
<li>Receives cyphertext</li>
<li>Uses key</li>
<li>Computes plaintext</li>
<li>Reads message</li>
</ol>
<h3 id="kerckhoffs-principle">Kerckhoffs’ Principle</h3>
<ul>
<li>From “La Cryptographie Militaire”</li>
<li>Most important point: <strong>The security of a crypto system must lie in the non-disclosure of the key but not in the non-disclosure of the algorithm</strong></li>
<li>Implementation
<ul>
<li>Keep secret which function you used for encryption</li>
<li>But a disclosure of the set of functions should not create a problem</li>
</ul></li>
</ul>
<h3 id="strong-algorithms">Strong Algorithms</h3>
<ul>
<li>There is no attack that can break it with less effort than a brute force attack (“complete enumeration”)</li>
<li>There are so many keys that a complete search of key space is infeasable</li>
</ul>
<h3 id="crypto-attack-classes">Crypto Attack Classes</h3>
<ul>
<li><strong>Active</strong> attacks
<ul>
<li>Most relevant for cryptographic protocols</li>
<li>Active interference (modification, insertion or deletion of messages)</li>
<li>Man in the middle (MITM) can receive messages and modify them on the way to the receiver</li>
</ul></li>
<li><strong>Passive</strong> attacks: Pure eavesdropping, without interference with communication</li>
</ul>
<h3 id="perfect-security">Perfect Security</h3>
<p>Cyphertext does not give any information you don’t already have about the plaintext</p>
<h3 id="one-time-pad">One-Time-Pad</h3>
<ul>
<li><strong>Vernam Cypher</strong>: Create ciphertext by XOR addition of secret key and plaintext</li>
<li><strong>Mauborgne</strong>: Random key, never re-use key (“one time”)</li>
<li><strong>Shannon</strong>: OTP is unbreakable if key is …
<ul>
<li>Truly random</li>
<li>As large</li>
<li>Never reused</li>
<li>Kept secret</li>
</ul></li>
</ul>
<h3 id="stream-ciphers">Stream Ciphers</h3>
<p>Encryption like one-time-pad, but using pseudo-random bits instead of true random (using a <strong>Crytographically Secure Pseudo-Random Number Generator (CSPRNG)</strong>)</p>
<h3 id="cryptographically-secure-pseudo-random-number-generators-csprng">Cryptographically Secure Pseudo-Random Number Generators (CSPRNG)</h3>
<p>A CSPRNG must …</p>
<ul>
<li>Be unpredictable</li>
<li>Be computationally infeasible to compute the next outputs</li>
</ul>
<p>… when the initial state of the CSPRNG is not known</p>
<h3 id="design-principles-for-block-ciphers">Design Principles for Block Ciphers</h3>
<p>Two methods for frustrating a statistical analysis:</p>
<ul>
<li><strong>Confusion</strong>: The ciphertext should depend on the plaintext in such a complicated way that an attacker cannot gain any information from the ciphertext (redundancy should not be visible anymore in the ciphertext)</li>
<li><strong>Diffusion</strong>: Each plaintext and key bit should influence as many ciphertext bits as possible
<ul>
<li>Changing one bit in plaintext → Many pseudo-random changes in cyphertext</li>
<li>Changing one bit in the key → Many pseudo-random changes in cyphertext</li>
</ul></li>
</ul>
<h3 id="feistel-networks">Feistel Networks</h3>
<ul>
<li>Described by Horst Feistel</li>
<li>Algorithm
<ul>
<li>Plaintext block B is divided in 2 halves</li>
<li>Derive r round key keys from key</li>
<li>Feed one half through round function F</li>
<li>Then XOR the result with the other half</li>
<li>Exchange halves</li>
</ul></li>
<li>Repeat r times</li>
</ul>
<h3 id="des-tripple-des">DES (Tripple DES)</h3>
<ul>
<li>Single DES breakable in less than 24h (complete search of key space)</li>
<li>Tripple DES is still secure</li>
<li>Three steps of DES on each data block using up to three keys</li>
<li>Decryption in reverse sequence</li>
<li>3 independend keys are the most secure</li>
<li>Three same keys can be used for (insecure) DES compatibility</li>
</ul>
<h3 id="aes-key-features">AES Key Features</h3>
<ul>
<li>FIPS standard 197</li>
<li>Key length: 128/192/256 bit</li>
<li>Block size: 128 bit</li>
<li>Iterative rounds of substitutions and permutation, but no Feistel structure</li>
<li>10, 12 or 14 rounds</li>
<li>Blocks of 16 bytes arranged in 4x4 state matrix</li>
<li>Components of the round function are invertible and independent of key
<ul>
<li><strong>Substitute Bytes</strong>: Non-linear substitution of bytes in state</li>
<li><strong>Shift Rows</strong>: Cyclic shifting of rows</li>
<li><strong>Min Columns</strong>: Multiplication of state elements with a fixed 4x4 matrix M</li>
</ul></li>
</ul>
<h3 id="modes-of-operation-for-block-ciphers">Modes of Operation for Block Ciphers</h3>
<ul>
<li>Objective: Encrypt multiple plaintext blocks with the same block cipher</li>
<li>Straightforward solution: blockwise encryption (“Electronic Codebook Mode”)</li>
<li>Problem: Patterns in the distribution of plaintext blocks remain visible</li>
</ul>
<h3 id="cipher-block-chaining-cbc">Cipher Block Chaining (CBC)</h3>
<ul>
<li>Avoids telltale patterns in ciphertext</li>
<li>Decryption fails if a data block is missing or corrupted</li>
<li>Each data block is encrypted in relation to the previous block</li>
</ul>
<h3 id="counter-mode-ctr">Counter Mode (CTR)</h3>
<ul>
<li>Simple and efficient</li>
<li>Random access still possible</li>
<li>No issues if data block is missing</li>
<li>Incrementing counter is involved in randomization per data block</li>
</ul>
<h3 id="padding">Padding</h3>
<ul>
<li>Plaintext needs to be a full number of blocks</li>
<li>If plaintext does not fill the last block completely, it must be padded before encryption
<ul>
<li>In order to facilitate safe decryption, the last block is always padded: For example for a block size of n bytes, there are 1…n bytes added to the plaintext before encryption</li>
<li>Decryption can check last bytes and strip them off correspondingly</li>
</ul></li>
<li>Always need to pad with at least one byte!</li>
<li>Common methods
<ul>
<li>Pad with bytes of the same value as the number of padding bytes (PKCS#5; i.e. if there are three bytes to be padded, add <code>0x03 0x03 0x03</code>)</li>
<li>Pad with <code>0x80</code> followed by <code>0x00</code> bytes</li>
<li>Pad with zeroes except for the last byte that indicates the number of padding bytes</li>
<li>Pad with zeroes</li>
<li>Pad with space characters (<code>0x20</code>)</li>
</ul></li>
</ul>
<h3 id="key-length-considerations">Key Length Considerations</h3>
<ul>
<li>Cryptography is always a matter of complexity
<ul>
<li>With enough time and/or space, all schemes can theoretically be broken</li>
<li>“brute force” attacks</li>
<li>Example: 56bit keys DES can be broken in &lt;24h since 1999</li>
</ul></li>
<li>Meanwhile
<ul>
<li>128bit keys have to be replaced in the coming years</li>
<li>192bit keys are secure in medium term</li>
<li>256bit keys are hard to crack due to physical boundaries</li>
</ul></li>
<li>Quantum computers might be able to crack keys much more quickly</li>
<li>Numbers refer to unbroken algorithms in symmetric cryptography
<ul>
<li>Broken algorithm is one where an n bit key can be determined trying out significantly less than 2<sup>n</sup> keys</li>
</ul></li>
</ul>
